from __future__ import annotations
# GlassServer/main.py
from __future__ import annotations

import os
import sqlite3
import tempfile
from pathlib import Path
from typing import List, Dict, Optional

from fastapi import FastAPI
from fastapi.responses import JSONResponse, FileResponse, Response
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from starlette.responses import RedirectResponse
from starlette.middleware.base import BaseHTTPMiddleware

from pydantic_settings import BaseSettings, SettingsConfigDict

# ---------- Paths ----------
BASE_DIR: Path = Path(__file__).resolve().parent
WEB_DIR: Path = BASE_DIR / "web"
STATIC_DIR: Path = WEB_DIR / "static"
DATA_DIR: Path = BASE_DIR / "data"

STATIC_DIR.mkdir(parents=True, exist_ok=True)
DATA_DIR.mkdir(parents=True, exist_ok=True)

DB_PATH: Optional[Path] = None

# ---------- Helpers ----------
def _to_bool(x: Optional[str], default: bool = False) -> bool:
    if x is None:
        return default
    return str(x).strip().lower() in {"1", "true", "yes", "y", "on"}

# Small middleware to add cache headers for /static/*
class StaticCacheMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        response = await call_next(request)
        if request.url.path.startswith("/static/"):
            # 1 day cache; tweak if you ship frequent hotfixes
            response.headers["Cache-Control"] = "public, max-age=86400"
        return response

# ---------- Settings (env-driven; .env in dev) ----------
class Settings(BaseSettings):
    # Local dev: read GlassServer/.env (ignored in prod if not present)
    model_config = SettingsConfigDict(
        env_file=str(BASE_DIR / ".env"),
        env_file_encoding="utf-8",
        extra="ignore",
        case_sensitive=False,
    )

    DOMAIN: str = os.getenv("DOMAIN", "https://www.glassapp.me")
    APP_VERSION: str = os.getenv("APP_VERSION", "1.0.0")

    DB_PATH: Optional[str] = os.getenv("DB_PATH")
    ADMIN_SECRET: Optional[str] = os.getenv("ADMIN_SECRET")

    TOKEN_TTL_DAYS: int = int(os.getenv("TOKEN_TTL_DAYS", "90"))

    DOWNLOAD_URL_PRO: str = os.getenv(
        "DOWNLOAD_URL_PRO",
        f"{os.getenv('DOMAIN','https://www.glassapp.me')}/static/Glass.exe",
    )
    ADDONS_URL: str = os.getenv(
        "ADDONS_URL",
        f"{os.getenv('DOMAIN','https://www.glassapp.me')}/static/pro_addons_v1.zip",
    )
    ADDONS_VERSION: str = os.getenv("ADDONS_VERSION", "1.0.0")

    STARTER_SALES_ENABLED: bool = _to_bool(os.getenv("STARTER_SALES_ENABLED"), False)
    STARTER_PRICE: str = os.getenv("STARTER_PRICE", "5")
    STARTER_BUY_URL: str = os.getenv("STARTER_BUY_URL", "")

    PRO_SALES_ENABLED: bool = _to_bool(os.getenv("PRO_SALES_ENABLED"), True)
    PRO_PRICE: str = os.getenv("PRO_PRICE", "5")
    PRO_BUY_URL: str = os.getenv("PRO_BUY_URL", "")

    FREE_MAX_WINDOWS: int = int(os.getenv("FREE_MAX_WINDOWS", "1"))
    STARTER_MAX_WINDOWS: int = int(os.getenv("STARTER_MAX_WINDOWS", "2"))
    PRO_MAX_WINDOWS: int = int(os.getenv("PRO_MAX_WINDOWS", "5"))

    INTRO_ACTIVE: bool = _to_bool(os.getenv("INTRO_ACTIVE"), True)
    PRICE_INTRO: str = os.getenv("PRICE_INTRO", "5")

    REFERRALS_ENABLED: bool = _to_bool(os.getenv("REFERRALS_ENABLED"), True)
    LAUNCH_URL: str = os.getenv("LAUNCH_URL", f"{os.getenv('DOMAIN','https://www.glassapp.me')}/launch")

    GUMROAD_SELLER_ID: Optional[str] = os.getenv("GUMROAD_SELLER_ID")
    GUMROAD_WEBHOOK_SECRET: Optional[str] = os.getenv("GUMROAD_WEBHOOK_SECRET")
    SKIP_GUMROAD_VALIDATION: bool = _to_bool(os.getenv("SKIP_GUMROAD_VALIDATION"), False)

    DRY_RUN: bool = _to_bool(os.getenv("DRY_RUN"), False)
    DEBUG: bool = _to_bool(os.getenv("DEBUG"), False)

settings = Settings()

# ---------- DB helpers ----------
def _preferred_db_path() -> Path:
    env = settings.DB_PATH or os.getenv("DB_PATH")
    if env:
        return Path(env)
    return DATA_DIR / "glass.db"

def _init_db(db_path: Path) -> bool:
    try:
        db_path.parent.mkdir(parents=True, exist_ok=True)
        with sqlite3.connect(db_path) as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS meta (
                    key TEXT PRIMARY KEY,
                    value TEXT
                )
            """)
            conn.execute("INSERT OR IGNORE INTO meta(key,value) VALUES(?,?)", ("schema", "1"))
            conn.commit()
        return True
    except Exception:
        return False

# ---------- App ----------
app = FastAPI(title="GlassServer", version=settings.APP_VERSION)

# Open CORS by default; tighten later if needed
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)
app.add_middleware(StaticCacheMiddleware)

@app.on_event("startup")
def on_startup() -> None:
    global DB_PATH
    cand = _preferred_db_path()
    if _init_db(cand):
        DB_PATH = cand
        return

    tmp_cand = Path(tempfile.gettempdir()) / "glass.db"
    if _init_db(tmp_cand):
        DB_PATH = tmp_cand
        return

    DB_PATH = None  # degraded but app still boots

# ---------- Static mount ----------
app.mount("/static", StaticFiles(directory=str(STATIC_DIR)), name="static")

# ---------- Routes ----------
@app.get("/healthz")
def healthz():
    info = {
        "status": "ok",
        "db_path": str(DB_PATH) if DB_PATH else None,
        "static_dir_exists": STATIC_DIR.exists(),
        "static_dir": str(STATIC_DIR),
        "version": settings.APP_VERSION,
        "domain": settings.DOMAIN,
    }
    if DB_PATH is None:
        info["status"] = "degraded"
        info["error"] = "DB not initialized (no writable path)"
    return JSONResponse(info)

@app.get("/")
def root():
    index_html = WEB_DIR / "index.html"
    if index_html.is_file():
        return FileResponse(index_html, media_type="text/html")
    return JSONResponse({"app": "GlassServer", "ok": True, "hint": "Place an index.html under GlassServer/web/ to serve it at /"})

@app.get("/static-list")
def static_list():
    files: List[str] = [
        str(p.relative_to(STATIC_DIR)).replace("\\", "/")
        for p in STATIC_DIR.rglob("*") if p.is_file()
    ]
    return JSONResponse({"count": len(files), "files": files})

@app.get("/static-check")
def static_check() -> JSONResponse:
    required = ["Glass.exe", "og.png", "pro_addons_v1.zip"]
    files: Dict[str, dict] = {}
    missing = []
    for name in required:
        p = STATIC_DIR / name
        exists = p.is_file()
        size = p.stat().st_size if exists else 0
        files[name] = {"exists": exists, "size_bytes": size, "href": f"/static/{name}"}
        if not exists:
            missing.append(name)
    ok = (len(missing) == 0)
    return JSONResponse({"ok": ok, "missing": missing, "files": files})

@app.get("/config")
def public_config():
    return JSONResponse({
        "domain": settings.DOMAIN,
        "version": settings.APP_VERSION,
        "token_ttl_days": settings.TOKEN_TTL_DAYS,
        "download_url_pro": settings.DOWNLOAD_URL_PRO,
        "addons_url": settings.ADDONS_URL,
        "addons_version": settings.ADDONS_VERSION,
        "sales": {
            "starter_enabled": settings.STARTER_SALES_ENABLED,
            "starter_price": settings.STARTER_PRICE,
            "starter_buy_url": settings.STARTER_BUY_URL,
            "pro_enabled": settings.PRO_SALES_ENABLED,
            "pro_price": settings.PRO_PRICE,
            "pro_buy_url": settings.PRO_BUY_URL,
        },
        "limits": {
            "free_max_windows": settings.FREE_MAX_WINDOWS,
            "starter_max_windows": settings.STARTER_MAX_WINDOWS,
            "pro_max_windows": settings.PRO_MAX_WINDOWS,
        },
        "intro": {"active": settings.INTRO_ACTIVE, "price_intro": settings.PRICE_INTRO},
        "referrals_enabled": settings.REFERRALS_ENABLED,
        "launch_url": settings.LAUNCH_URL,
        "skip_gumroad_validation": settings.SKIP_GUMROAD_VALIDATION,
        "dry_run": settings.DRY_RUN,
        "debug": settings.DEBUG,
    })

@app.get("/download/latest")
def download_latest():
    f = STATIC_DIR / "Glass.exe"
    if f.is_file():
        return FileResponse(str(f), media_type="application/octet-stream", filename="Glass.exe")
    return RedirectResponse(url=settings.DOWNLOAD_URL_PRO, status_code=302)

@app.get("/addons/latest")
def addons_latest():
    f = STATIC_DIR / "pro_addons_v1.zip"
    if f.is_file():
        return FileResponse(str(f), media_type="application/zip", filename="pro_addons_v1.zip")
    return RedirectResponse(url=settings.ADDONS_URL, status_code=302)

# Explicit HEAD handlers so PowerShell -Method Head works nicely
@app.head("/download/latest")
def head_download_latest():
    f = STATIC_DIR / "Glass.exe"
    if f.is_file():
        return Response(status_code=200)
    return RedirectResponse(url=settings.DOWNLOAD_URL_PRO, status_code=302)

@app.head("/addons/latest")
def head_addons_latest():
    f = STATIC_DIR / "pro_addons_v1.zip"
    if f.is_file():
        return Response(status_code=200)
    return RedirectResponse(url=settings.ADDONS_URL, status_code=302)

# (Optional placeholders; keep commented until implemented)
# from fastapi import APIRouter
# license_router = APIRouter()
# @license_router.post("/issue")    def issue_license(payload: dict):    return {"ok": True}
# @license_router.post("/activate") def activate_license(payload: dict): return {"ok": True}
# @license_router.post("/validate") def validate_license(payload: dict): return {"ok": True}
# app.include_router(license_router, prefix="/license", tags=["license"])
# webhook_router = APIRouter()
# @webhook_router.post("") def gumroad_webhook(payload: dict): return {"ok": True}
# app.include_router(webhook_router, prefix="/gumroad/webhook", tags=["webhook"])

